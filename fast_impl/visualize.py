# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/09_CNN_Interpreter.ipynb (unless otherwise specified).

__all__ = ['generate_cam', 'CamImage', 'get_at', 'show_at', 'show_cam_batch', 'BaseInterpreter', 'batch_none',
           'CamInterpreter']

# Cell
from fastai2.vision.all import *
import gc
import copy
from .core import arch_summary, get_module, min_max_scale
from .transforms import to_grayscale

# Cell
def generate_cam(model,xb,act_path:list=[0],wt_path:list=[1,-1],with_preds=False):
    """Show CAM for a given image
    `act_path`: list of indices to reach activation maps layer
    `wt_path`: list of indices to reach weight layer
    """
    if len(xb.shape)==3: xb= xb[None]

    act_layer = get_module(model,act_path)
    wt_layer = get_module(model,wt_path)
    with hook_output(act_layer) as hook:
      y_preds = model(xb)
      act = hook.stored
      cam = torch.einsum('ck,nkij->ncij', wt_layer.weight, act)

      #cleanup: to prevent memory-error
      del act,xb
      torch.cuda.empty_cache()

    if with_preds: return cam, y_preds
    return cam

# Cell
class CamImage:
  def __init__(self,x_dec,y_dec,pred_cls,cam:torch.Tensor):
    store_attr(self,'x_dec,y_dec,pred_cls,cam')

  def show(self,ctx=None,merge=True):
    imsize = 5 if merge else 7
    if ctx is None:
      _,ctx = subplots(1,1 + int(not merge),figsize=(imsize,imsize))
    else:
      if not is_listy(ctx):
        # ctx is available, but only one, so merge
        merge=True
        ctx = [ctx]
      elif len(ctx)==2:
        # two ctx are available, so merge=False
        merge=False

    ax = self.x_dec.show(ctx=ctx[0])
    ax = self.y_dec.show(ctx=ax)
    is_correct = self.pred_cls==self.y_dec
    ax = show_title(self.pred_cls,ctx=ax,color='green' if is_correct else 'red')
    alpha = 0.6 if merge else 1.
    show_heatmap(self.cam,self.x_dec.shape[-1],ax=ctx[int(not merge)],alpha=alpha)

# Cell
def get_at(batch_dec,cam_batch,y_preds,idx,for_cls=None)->CamImage:
  x,y = batch_dec[idx]
  cam_i = cam_batch[idx]
  del cam_batch # we don't need batch anymore, free-up memory

  if for_cls is not None:
    del y_preds
    class_id = for_cls
  else:
    class_id = y_preds[idx].argmax(-1).item()
  return CamImage(x,y,dls.vocab[class_id],cam_i[class_id])

def show_at(model,xb,yb,idx,merge=True,for_cls=None):
  xib,yib = xb[idx][None],yb[idx][None]
  batch_dec = dls.decode_batch((xib,yib))
  cam_b,y_preds = generate_cam(model,xib,with_preds=True)
  get_at(batch_dec,cam_b,y_preds,idx=0,for_cls=for_cls).show(merge=merge)

# Cell
def show_cam_batch(xb,yb,cam_batch,y_preds,max_n=9,merge=True,nrows=None, ncols=None, figsize=None):
  ctxs = get_grid(min(xb.shape[0],max_n),double=(not merge),add_vert=4,title='Target/Prediction')
  batch_dec = dls.decode_batch((xb,yb))
  getter = partial(get_at,batch_dec,cam_batch,y_preds)
  if merge:
    for idx,ctx in enumerate(ctxs):
      cam_img = getter(idx)
      cam_img.show(ctx=ctx)
  else:
    for idx,ctx in enumerate(zip(ctxs[0::2],ctxs[1::2])):
      cam_img = getter(idx)
      cam_img.show(ctx=ctx)

# Cell
class BaseInterpreter:
  def __init__(self,model:nn.Module,dls:DataLoaders,valid_dl:DataLoader=None):
    self.model = copy.copy(model.eval())
    self.dls = dls
    self.valid_dl = ifnone(valid_dl,copy.copy(dls.valid))
    self.valid_dl.shuffle=True

  @classmethod
  def from_learner(cls,learn:Learner,ds_idx=1,dl=None):
    if dl is None: dl = learn.dls[ds_idx]
    return cls(learn.model,learn.dls,dl)

  def is_cam_compatible(self,model:nn.Module=None):
    """Check whether model is compatible for CAM
    The requirement is `GlobalAveragePooling` should be the penultimate layer
    """
    avg_idx=-1
    if model is None: model = self.model
    layers = flatten_model(model)
    for idx,layer in enumerate(layers):
      if isinstance(layer,(nn.AvgPool2d,nn.AdaptiveAvgPool2d)):
        avg_idx = len(layers) - idx - 1
    if not avg_idx in [1,2]: return False #AvgPool is not penultimate
    return True

  def label_list(self):
    "Show Class labels and indices (pretty-print `dls.vocab`)"
    df = pd.DataFrame(self.dls.vocab,columns=['category'])
    return df

# Cell
def batch_none(xb,yb):
  return xb is None and yb is None

class CamInterpreter(BaseInterpreter):

  @delegates(generate_cam)
  def generate(self,xb=None,yb=None,**kwargs):
    if batch_none(xb,yb):
      xb,yb = self.valid_dl.one_batch()
    return generate_cam(self.model,xb,**kwargs)

  @delegates(show_cam_batch,but=['xb,yb,cam_batch,y_preds'])
  def show_batch(self,xb=None,yb=None, **kwargs):
    if batch_none(xb,yb):
      xb,yb = self.valid_dl.one_batch()
    cam_batch,y_preds = self.generate(xb,with_preds=True)
    show_cam_batch(xb,yb,cam_batch,y_preds,**kwargs)